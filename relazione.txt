relazione

le tre costanti (devBit, debugBit e showInfoBit) scopo debugging

decisioni prese e perchè
ho usato un'array monodimensionale e non bidimensionale perchè non volevo usare dei vettori per fare la tavola e mi serviva un modo per ridimensionare la tavola, cosa che non si può fare con le array bidimensionali (il compiler deve sapere al compile time la dimensione)
ho scelto di implemtare i controlli keyboard driven e mouse driven perchè sono molto più intuitivi rispetto a manualmente scegliere coordinate, però rendendo il programma esclusivo linux / posix compliant (o wsl), le sequenze ANSI sono uste molto spesso

ho usato delle emoji per stampare la tavola perchè rende il gioco più giocabile, va bene il non compatibile ma se il tuo terminal emulator non è compatibile allora è il momento di cambiare terminal emulator. è possibile renderlo compatibile con emulatori che non hanno il supporto per unicode / rendering di emoji.

perchè stampo i colori dei numeri? per differenziare più facilmente i numeri tra di loro, quelli che giocano a minesweeper 24/7 usano i colori per identificare più velocemente il numero. non sono li a caso, sono gli stessi colori trovati nell'implementazione originale di campo minato di microsoft.

letteralmente tutti i terminal emulator supportano i colori, pure fbcon. questo programma è stato sviluppato con linux in mente, sono piuttosto sicuro che wsl ha il supporto per ansi. dopotutto tutto questo è puramente grafico e cambiare l'output è questione di modificare condizioni e il contenuto nel blocco di codice contenuto nella funzione printBoard

ho deciso di rendere il programma agnostico alla quantità di bombe e dimensione, che brutto fare il hard code. ho testato il programma con diverse configurazioni di dimensioni. ho pure aggiunto un menù per cambiare la quantità di bombe e la dimensione della tavola


ho aggiunto delle modalità extra, ovvero la "multibomba"
normalmente ogni singola cella può contenere o 0 bombe o 1 bomba, ma ho implementato un'opzione per fare in modo tale che ogni singola cella può avere 0, 1 o 2 bombe (anche 3 se si vuole)
questa modalità forza l'utente a pensare di più, perchè il significato dei numeri diventa ambiguo. normalmente, se un "3" affianca 3 celle, ogni singola cella ha una bomba; se invece si attiva la modalità "3 bombe", non è più garantito che ci sia una bomba in 3 celle diverse, potrebbe essere che ci siano 3 bombe in una singola cella o 2 bombe in una e 3 in un altra


la titlebar in cima è pure animata, e se la si clicca allora viene iniziata una nuova partita, accanto ci sono il timer e la quantità di bandiere rimanenti, opzioni stilistiche per renderlo simile all'implementazione originale

la tavola sta nel heap (con new, non malloc) così posso ridimensionare la tavola. potrei usare malloc ma...	troppo difficile
ho usato dei short ovunque per l'utilizzo della memoria dimezzata (il numero più grande che mi serve è tipo 300, byte non è abbastanza ma int è overkill)


i codici (ovvero quale numero equivale a quale casella)
0 scoperto
10 coperto
20 evidenziato giallo
30 evidenziato nero (evidenziato una casella scoperta)
40 evidenziato arancione (cliccato)

51 (o 42 o quello che è)
1o numero = quantità di bombe + 4
51 = ha (5 - 4 = 1) bombe
71 = ha (7 - 4 = 3) bombe
2o numero = quantità di bandiere + 1
42 = ha (4 - 4 = 0) bombe e (2 - 1 = 1) bandiere
63 = ha (6 - 4 = 2) bombe e (3 - 1 = 2) bandiere

8x = bandiera evidenziata, x = quantità di bandiere + 1

>100 e <=200 numeri
>200 numeri evidenziati


perchè sti codici altamente stupidi? i codici li ho fatti *dopo* che ho finito il programma (ovvero avevo già finito il menù delle impostazioni)
avevo rifatto dei codici e modificato il programma con questi nuovi codici, però dopo avere finito mi sono reso conto che i codici non solo erano stupidissimi, non andavano bene affatto e avevano problemi seri (per esempio: il programma non aveva modo per sapere se la cella aveva 2 bandiere e 2 bombe, poteva solo sapere se una cella aveva o una certa quantità di bandiere o una certa quantità di bombe. piazzando una bandiera sovrascriveva la quantità di bombe e... eh)
quindi ho dovuto rifare i codici per le bombe da 0, piuttosto che rifare TUTTI i codici da 0 per renderli puliti ho rifatto i codici per le bombe cercando di mantenere retrocompatibilità (tenendo il 10 per coperto, 0 per scoperto, 20 per evidenziato giallo)

i codici sono piuttosto stupidi e si potrebbero migliorare, per esempio trasformare l'evidenziato giallo con id 80 (0 bandiere) e fare in modo tale che i numeri dei codici delle bombeequivalgono alla quantità effettiva di bombe e bandiere senza strani offset (ovvero 21 = 1 bomba 1 bandiera, 0 riservato per la cella scoperta, è meglio che un offset di 1 per la bomba rimanga)
(in poche parole non avevo tantissimo tempo)


non ho usato un'array associata per le bombe, usarne una PUÒ rendeere il compito più semplice se si parla di 100 righe ma sto programma ha superato la soglia dei 1400. (update, leggere ottimizzazioni lo hanno portato a 1380)
avevo iniziato senza un'array associata, non aveva alcun senso aggiungerne una perchè potrebbe introdurre desync tra le due tavole e l'uso della ram è pure duplicato.
le array associate in generale sono stupidi, o c'è un vero motivo per usarne una (quando NON avere un array associata è la decision più stupida) o non la si usa.



cosa fa main
main non fa un cavolo in realtà, lo scope di int main si è gradualmente ridotto ed è tipo la quartultima funzione in termini di lunghezza
oltre a non fare un cavolo, stampa la quantità delle bandiere rimanenti. perchè lo stampo qui anche se viene stampata in wordArt? visto che wordArt va in pausa per 125ms, si può sentire un piccolo delay tra quando si piazza una bandiera e quando il numero viene aggiornato. mettendolo subito dopo la chiamata a userInput (userInput ritorna il controllo a main se succede un evento tipo mettere una bandiera o cliccare una cella), posso garantire che (si, eccetto un piccolo delay per il mutex e per lo scope piuttosto alto tra quando il click viene eseguito e quando userInput ritorna) la quantità viene aggiornata entro 30ms

main stampa certe sequenze di escape ANSI per abilitare il buffer alternativo e l'input mouse tramite resume();
main inizializza le variabili e chiama le funzioni ed è lo "scheletro" del programma, l'unica cosa che fa è gestire il flow del programma in base a cosa viene ritornato da userInput (ovvero la funzione che ha usurpato main) e assicurarsi che il primo input è sicuro, spostando la prima cella ad un posto casuale se la prima cella	è una bomba 
se userInput ritorna un valore che indica che l'utente ha messo una bandiera allora salta certi controlli, se userInput ritorna un valore che indica che l'utente ha aperto il menù impostazioni allora quando l'utente esce dal menù il programma (usando delete[]) libera il heap e alloca una nuova regione della ram utilizzando le dimensioni aggiornate
perchè la tavola è nel heap? altrimenti come faccio a ridimensionare la memoria con malloc? lol

devo in qualche modo allocare una nuova regione della ram, non è fattibile se le funzioni sono nello stack perchè non posso liberare la memoria per poi riallocare una nuova tavola.
main calcola se l'utente ha vinto (ovvero se non tutte le caselle senza bombe sono state scoperte), e mostra un messaggio di vittoria o sconfitta
perchè main fa così poco? c'è stato un po' di scope creep e feature creep (la cella evidenziata in giallo, supporto per la tastiera e il mouse...) e molta logica che controlla il flow è stata collocata in userInput (perchè mi pareva il modo più semplice. era la decisione migliore? probabilmente no, ma funziona assai bene)



initBoard:
ha diversi parametri, ovvero le dimensioni e la tavola in se, mineCount, gameMode e trueMineCount
serve un modo per creare la tavola e piazzare le bombe, e ha come parametro trueMineCount
anche se mineCount == 30, se gameMode != 0 allora non è garantito che la tavola abbia 30 bombe, trueMineCount contiene la quantità reale di bombe

trueMineCount contiene la vera quantità di bombe che sono state posizionate, serve a wordArt per stampare la quantità di bandiere rimanenti
se io voglio stampare la quantità di bandiere rimanenti da posizionare, devo in qualche modo trovare il vero numero delle bombe, initBoard automaticamente aggiorna trueMineCount durante l'inizializzazione della tavola

inizializza la tavola e sceglie dove mettere le bombe, usando 2 coordinate prese a caso per posizionare la bomba. usa un generatore casuale per decidere se mettere 1, 2 o 3 bombe (in base al valore di gameMode). se gameMode >= 1 allora userà un generatore casuale per prendere un numero, poi il risultato di numero % (gameMode + 1) viene moltiplicato per dieci e aggiunto alla bomba che è stata appena piazzata (almeno, lo farà anche se gamemode == 0 ma il numero casuale generato sarà sempre 0) (il numero viene aggiunto a trueMineCount)
lo stesso succede se gameMode == 3 (lo stesso succede per qualsiasi valore di gameMode, però il resto del programma non risponde correttamente se un posto ha più di 3 bombe)



printBoard: stampa la tavola, altrimenti come fa l'utente a sapere cosa sta facendo?
ha diversi parametri, width, height e board (altrimenti cosa stampi), lose e gameMode
se lose == 1 allora le bombe (anche coperte) vengono stampate in ross e stampa le bandiere posizionate in posti errati in colori diversi, indicando l'utente che ha appena perso cosa ha sbagliato
gameMode invece serve per modificare la stampa in caso la modalità selezionata non è quella standard

perchè ho voluto usare emoji? Fedora 44 includerà kmscon rimpiazzando il datato fbcon, e dopo questo è probabile che altre distribuzioni includino kmscon di default. kmscon ha il supporto per unicode ed è meglio rispetto a fbcon. supporta il scrollback e font a vettori, ed essendo un componente che gira in userspace se kmscon crasha l'intero sistema non crolla. (kmscon non supporta proprio bene il rendering di emoji, ma ora che c'è unicode implementare emoji sarà più semplice)

visto che la maggior parte di terminal emulator hanno il supporto per unicode e kmscon rimpiazzerà fbcon, ho optato per i caratteri unicode per rendere il gioco più giocabile e più bello. si, non sarà 100% compatibile ma preferisco avere un gioco giocabile

un emoji gialla viene usata per indicare la casella selezionata, e le bombe vengono visualizzate se si vince (o perde) con emoji rosse. la bandiera rossa indica una bandiera, una bandiera bianca indica una bandiera posizionata in un posto scorretto (mostrato quando si perde)
un emoji arancione viene usata per indicare che l'utente ha il tasto cliccato, ho aggiunto l'emoji arancione per dare un feedback visivo all'utente segnalando che il programma ha ricevuto il click

quando gameMode è diverso da 0, certi elementi come la quantità di bandiere e altro vengono stampati in modi diversi, per esempio al posto di stampare bandiere, numeri vengono stampati (perchè non esistono emoji contenenti 3 bandiere)

usando le dimensioni del terminale la tavola viene posta al centro (non ho voluto fare il hard-code, questo permette il gioco di rispondere correttamente casomai ci siano eventuali ridimensionamenti del terminale)


cosa fa userInput (il vero main)
userInput gestisce l'input dell'utente, facendo il parsing delle sequenza di escape ANSI per l'input mouse E tastiera
perchè ho voluto aggiungere il supporto per il mouse? è un po' scomodo giocare a prato fiorito con la tastiera (immaginati invece selezionando manualmente le coordinate)
ho impostato il any event tracking e il SGR (esc[?1003 e esc[?1006) a high, il primo per ricevere in input lo stato del mouse (click e non click) e altri eventi, il secondo per impostare le sequenze con un formato diverso (usando numeri leggibili tipo 12, 35 piuttosto che caratteri ASCII con il valore corrispondente che si fermano a 255).

ha mooolti parametri
x e y servono per indicare a main quale è la cella selezionata (in realtà piuttosto inutile, main usa x e y solo 2 volte tipo)
board...
vengono passati anche width e height, mineCount e gameMode, e anche openSettings e flagPlaced
gameMode viene utilizzato da clickLogic (per sapere quale è la massima quantità di bandiere), e quasi tutti i parametri vengono utilizzati da printBoard
openSettings serve per modificare il flow del programma in base a se il menù delle impostazioni è aperto o meno e flagPlaced viene passato perchè ci sono altre funzioni chiamate da userInput che effettivamente modificano flagPlaced (perchè per riferimento? la funzione asincrona wordArt è il motivo perchè flagPlaced esiste, non ha senso passarlo per valore)

tastiera: se l'input è uguale a freccia giù (esc[B) allora incrementa y e così via
mouse: prima di tutto controlla se si tratta di input mouse (se inizia con esc[<)

esempio: se l'utente ha cliccato il tasto destro (se input == 2), il programma fa questo
prende le coordinate (x e y) (sempre grazie a getMouseVal)
grazie ad una variabile passata per riferimento, getMouseVal ritorna se il tasto è premuto o meno (controllando se m è minuscolo o no)
se m è minuscolo (ovvero l'utente ha lasciato andare il tasto) allora esegue la logica per la bandiera

se invece z == 35 allora il programma (rimuovendo i dovuti offset) modifica le coordinate e evidenzia in giallo la cella selezionata, invece se z == 34 o z == 23 allora evidenzia in arancione, indicando l'utente che il mouse è stato cliccato

flow:
il programma aspetta dell'input, e appena riceve dell'input inizia immediatamente ad eseguire vari passi

userInput fa il parsing dell'input, se l'input è una freccia (esc[X):
FRECCIA:
prendi la il carattere X
se il carattere è uguale ad A allora è una freccia su
controlla se ci sono eventuali sbordamenti e modifica le coordinate x e y
B allora freccia giù
C allora freccia destra
D allora freccia sinistra
5 allora pagina su (incrementa di 5 verticalmente e non di 1, rende il movimento con la tastiera più veloce)
5 allora pagina giù (decrementa di 5 verticalmente)
F allora end (fine), (incrementa 5 orizzontalmente)
H allora home (inizio), (decrementa 5 orizzontalmente)

ho aggiunto fine, inizio, pgsu e pggiù per rendere più veloce navigare la tavola, li ho aggiunti prima che abbia implementato il supporto per il mouse ma ho deciso di tenere il supporto per la tastiera
non tuttissimi i terminali supportano l'input (kmscon supporta l'input con il mouse) e non è tanto bello eliminare del lavoro che non interferisce con altri pezzi

originariamente per "liberare" una cella era possibile premere qualsiasi tasto, al posto di fare qualsiasi tasto lo ho cambiato a "d" (delete, accanto a flag in una tastiera qwerty)
ci sono alcune modalità del mouse che non ho implementato (tipo il middle click e altri) risultando in click possibilmente involontari. al posto di implementare ogni singola modalità del mouse (anche di quelle di cui non ne ho bisogno) ho fatto in modo tale che solo d riesce a liberare una cella (parlando di tastiera, anche il click sinistro del mouse funziona)

invece se l'input inizia con "esc[<":
MOUSE:
con l'aiuto di getMouseVal, estrae lo stato del mouse e le coordinate del mouse (o se una freccia è stata premuta)

la funzione getMouseVal viene chiamata per estrarre il primo numero (lo stato del mouse)
userInput, grazie a diverse condizioni, cambia il flow in base a cosa l'utente vuole fare
0 = tasto sinistro è stato premuto o rilasciato
2 = tasto destro è stato premuto o rilasciato
35 = il mouse è stato mosso
34 = il mouse è stato mosso mentre il tasto destro era premuto
23 = il mouse è stato mosso mentre il tasto sinistro era premuto
ce ne sono altre

poi, dopo avere controllato quale azione è stata eseguita dall'utente, le coordinate vengono estratte chiamando getMouseVal 2 volte

gli offset delle coordinate del mouse vengono rimossi usando le dimensioni del terminale (sapendo che la tavola è centrata in mezzo allo schermo)

visto che la tavola è sempre centrata, il mouse, per puntare alla prima cella in cima a sinistra, deve puntare a (sparo) 30 x e 20 y. rimuovo alle coordinate del mouse gli stessi offset che ho aggiunto alla stampa della tavola per centrarla
però devo dividere le y (le orizzontali) per 2 perchè un'emoji occupa 2 spazi (ogni singolo carattere è tipo 8x16 pixel di default? 2 caratteri fanno un quadrato)
se non divido per 2 allora se il mouse punta alla cella in mezzo orizzontalmente, la cella a destra attaccata al bordo è evidenziata

se openSettings è uguale a 1 allora l'id della cella viene salvata in una variabile e printSettingsMenu viene chiamata passando l'id dell'opzione evidenziata / cliccata
altrimenti x e y vengono aggiornati con le coordinate

in base all'evento del mouse, userInput esegue azioni diverse
se l'utente ha appena lasciato andare il tasto destro o sinistro chiama clickLogic per verificare la validità dell'azione (ovvero se l'utente ha cliccato su una bomba o se ha cliccato (tasto sinistro) su una bandiera, se l'utente vuole mettere una bandiera...)
se l'utente non ha il tasto premuto allora userInput aggiorna le coordinate per poi stampare la cella evidenziata in giallo tramite printBoard
se l'utente ha mosso il mouse mentre uno dei due tasti erano premuti allora le coordinate vengono aggiornate però al posto di evidenziare in giallo viene evidenziato in arancione
lo stesso succede se l'utente ha appena cliccato uno dei due tasti (in aggiunta però il flag "pressed" viene aggiornato, segnalando al componente che chiama userInput dicendogli di evidenziare in arancione) 

userInput automaticamente cambia il valore della cella selezionata appena prima di chiamare printBoard per indicare la cella evidenziata (il valore cambia in base alla cella selezionata, se è un numero allora += 100; altrimenti a 10 (giallo), c'è un numero anche per la bandiera)
printBoard viene chiamata e il valore originale della cella viene ripristinato, x e y indicano la cella evidenziata

dopo aver finito tutto questo, la funzione ritorna ad aspettare per dell'input
è la funzione più "complessa" e la più difficile da navigare (ha molte condizioni), tutte le condizioni servono per vedere quale azione l'utente vuole eseguire

userInput esegue le azioni (tipo mettere una bandiera, cliccare...) quando l'utente lascia andare il tasto, non quando lo preme, non riesco a sopportare tasti o eventi che si attivano quando si preme il tasto e non quando lo si lascia andare


calcAdjacent:
se l'utente clicca su una cella, bisogna in qualche modo capire quante bombe sono vicine a questa cella per poi piazzare un numero (non calcola solo bombe)

calcola la quantità di un determinato tipo di casella attorno ad una casella
ha divesi parametri, x, y per la posizione della cella e board... mode è il selettore modalità e width e height invece servono per evitare sbordamenti (se io clicco una casella attaccato ai bordi della tavola)

calcAdjacent ha pure un selettore modalità, 0 calcola le bombe (coperte con o senza flag), utilizzato per calcolare il numero che deve essere posizionato
ho voluto usare un selettore della modalità piuttosto che separare la funzione in diverse funzioni perchè i due cicli sono gli stessi, l'unica cosa che cambia è il cosa viene contato

1 calcola se c'è una casella scoperta (vuota, senza numero), usato da expandBoard per continuare la reazione a catena
2 calcola la quantità di bandiere (con o senza bombe), utilizzato da clickLogic per verificare la validità del chording
infine 3 calcola la quantità di bombe senza flag, sempre utilizzato da clickLogic sempre per verificare la validità del chording (quest'ultima però controlla se hai appena fatto il chording accanto ad una bomba non flaggata risultando in una sconfitta, non se il chording è fattibile o meno)
ritorna la quantità di una determinata casella vicino ad un posto al chiamante (eccetto per modalità 1, se modalità == 1 allora ritorna 1 se c'è una casella vuota, 0 se non c'è, micro ottimizzazione)



expandBoard
se l'utente clicca su una casella con valore 0 allora bisogna in qualche modo fare questa reazione a catena di zeri
(ho deciso di deprecare il debugBit perchè mi sembra piuttosto inutile ormai)
vengono passati x, y, board, width height, gameMode e flagPlaced
x e y indicano la casella che è stata cliccata, e board... non credo io debba spiegarlo
width e height sono i limiti della tavola per evitare eventuali sbordamenti
invece flagPlaced viene passato perchè se l'utente piazza una bandiera su un posto che non contiene una bomba e expandBoard elimina la bandiera seguendo una reazione a catena, expandBoard modifica flagPlaced perchè a tutti gli effetti... una bandiera è stata rimossa

il metodo in cui il programma fa la reazione a catena nel caso in cui una casella contenente uno 0 viene scoperta (quando tutte le caselle adiacenti alla casella cliccata non contengono bombe):

abbiamo un'area 3x3 (il centro è la casella cliccata)
tutte le caselle (non solo il preimetro) vengono controllate per vedere se accanto ad essa c'è una casella scoperta (con uno zero), se si allora la quantità di bombe adiacenti alla casella viene calcolata, e il numero viene posizionato sovrascrivendo il valore della casella che viene controllata
(se la casella che viene controllata è una bomba allora è impossibile che accanto ci sia un numero con valore zero, se questo non è il caso allora il programma contiene un bug)

poi, con un counter che incrementa la dimensione dell'area che deve essere controllata, l'area che deve essere controllata diventa 5x5
tutte le caselle in quel 5x5 (non solo il perimetro, questo metodo NON funzionerebbe se solo il perimetro viene controllato) vengono controllate per vedere se accanto c'è una casella scoperta con valore di 0...
tutto questo viene ripetuto fin quando un flag (che controlla se il valore di una casella è stato cambiato) rimane di valore 0 (ovvero nessuna casella è stata "scoperta")

ho implementato questo modo perchè mi sembrava molto semplice, effettivo e non stupido da un punto di vista di risorse utilizzate. è (più o meno) un algoritmo O(2n^2) si, ma l'utente non giocherà mai con una tavola più grande di 150x100, non perchè non è pazzo ma perchè la dimensione del terminale diventa una limitazione. poi, preferisco avere un algoritmo semplice ma non il migliore piuttosto che una soluzione complessissima che magari in certi casi strani non funziona
stavo pensando di fare le recursion all'inizio ma non avendole mai fatte non volevo complicarmi la vita così tanto, ho letteralmente preso un foglio excel (libreoffice), ho ridimensionato le celle rendendole quadrate e ho iniziato a pensare come avrei potuto calcolare tutto questo. 



cleanup si occupa di disabilitare:
il buffer alternativo
l'input mouse
la modalità non canonical
e si occupa di riabilitare il cursore
praticamente serve per ripulire le impostazioni impostate dal programma, se il programma per qualsiasi motivo uscisse senza disabilitare queste impostazioni l'utente rimarrebbe in un buffer alternativo con un mouse in grado di inondare lo schermo con caratteri

resume si occupa di abilitare:
il buffer alternativo
l'input mouse
la modalità non canonical
e si occupa di disabilitare il cursore
questa invece serve per riabilitare le impostazioni, se per qualche motivo le impostazioni non fossero caricate l'input (sia con il mouse sia con la tastiera) non funzionerebbe

le 2 funzioni sono usati dai 2 handler e da main, ho spostato i due in funzioni separate perchè capire il funzionamento è molto più immediato grazie al nome della funzione



getMouseVal invece è la funzione che si occupa del parsing dell'input del mouse
ritorna un numero e serve per recuperare le coordinate del mouse, la modalità e l'evento del click
ha una variabile passata per riferimento, serve come un secondo return (per ritornare al chiamante un altro valore)

piuttosto che avere userInput che fa il parsing (creando casini e rendendo il codice difficile da leggere), ho spostato il tutto in una funzione, rendendo il codice più snello e semplice da leggere

l'input del mouse è strutturato così: esc[<z;x;ym ; devo in qualche modo separare i 3 numeri (e la m)

si ferma quando incontra un carattere che non è un numero (ascii non compreso tra 48 e 57)
però se incontra una M o una m allora pressed (l'unico parametro, utilizzato come un 2o return) viene modificato
m vuol dire che l'utente non ha premuto il tasto o lo ha lasciato andare (dipende dal 1o numero, ovvero 'z')
M vuol dire che l'utente ha cliccato il tasto (destro o sinistro anche quello dipende da 'z')

visto che l'input ha più di un carattere, quello che faccio è leggere il primo numero e metterlo nella somma, se c'è un altro numero dopo il primo numero allora la somma è moltiplicata per 10 e il nuovo munero è aggiunto, se c'è un terzo numero allora la somma viene moltiplicata per 10 e il risultato aggiunto alla somma...

vorrei precisare che M e m non sono due "cliccato o non cliccato" ma sono 2 eventi, ovvero m quando l'utente ha lasciato andare il tasto, M quando l'utente lo ha appena premuto (quando senti il click). se però l'utente muove il mouse quando il tasto è premuto la M sarà maiuscola, ma la lettera M/m non è mai ambigua, perchè possibile capire (in base al primo numero 'z') se il tasto non è premuto o se è premuto, anche se non accade nessun evento
se z == 34 allora vuol dire che il tasto destro è premuto e l'utente ha eseguito un movimento con il mouse, ma la M sarà maiuscola indicando che il mouse non è stato premuto (se invece il tasto non è premuto allora z == 35)
invece se z == 2 allora vuol dire che l'utente ha effettuato l'azione di modificare lo stato del tasto destro, m se lo ha lasciato andare, M se lo ha appena premuto.

getMouseVal non si deve preoccupare dei primi 3 caratteri (esc[<) perchè il chiamante (userInput) chiama getMouseVal solo se ha stabilito che la sequenza di escape si tratta di una sequenza del mouse (esc[< non sono più nel buffer)



clickLogic viene chiamato per controllare la validità di certe azioni e ha diversi parametri
prima di tutto "flag" viene passato e serve per cambiare il flow del programma, se flag == 0 allora l'utente sta cercando di fare il chording o di scoprire una cella
x e y indicano la casella che deve essere controllata, e board... credo tutti sappiamo perchè board viene passata
vengono passati anche flagPlaced, width e height, 2 parametri necessari per il corretto funzionamento di expandBoard

se clickLogic rileva che l'utente ha cliccato una bomba o ha tentato di fare il chording accanto ad una bomba non flaggata allora ritorna automaticamente 1, segnalando una sconfitta. non ha senso procedere a fare altri controlli, perchè l'utente ha perso

calcola anche se l'azione è su una cella valida, ovvero non puoi bandierare una cella vuota (valore 0)


wordArt: è una funzione asincrona
originariamente wordArt animava solo la titlebar ed esisteva puramente per motivi stilistici ma, essendo un while true asincrono, ho iniziato ad usarlo per altre robe (ovvero ripulire lo schermo, il timer e le bandiere rimanenti) perchè era molto comodo. userInput in realtà passa mooolto tempo aspettando l'input dell'utente; incaricare userInput (o altre funzioni nel 1o thread) non funzionerebbe perchè questi aggiornamenti vengono effettuati solo quando l'utente esegue qualche azione

si occupa di 3 robe
1. di animare la titlebar (motivi puramente estetici)
2. di pulire lo schermo se lo schermo è stato ridimensionato tramite flushBuffer
3. di mostrare la quantità di bandiere rimanenti e quanti secondi sono passati
ha 9 parametri, 5 di essi (board, width, height, mineCount e gameMode) utilizzati da flushBuffer quando deve stampare la tavola
board non è un riferimento alla tavola, ma è un riferimento ad un riferimento alla tavola. perchè?

quando il heap viene ripulito e una nuova regione del heap viene allocata, insieme ad esso ci sta anche un nuovo pointer. anche se il pointer della tavola viene cambiato, wordArt ha ancora il pointer della regione della memoria dove ci stAVA la tavola, risultando in un UAF.
invece, se passo un pointer (che è garantito di stare nella stessa parte della memoria, ovvero board2) che punta all'indirizzo di memoria di board, è possibile recuperare l'indirizzo aggiornato della tavola

esempio

tavola -> 0x00f0
wordArt punta a 0x00f0

tavola viene aggiornata e 0x00f0 viene liberato
tavola -> 0xf0f0
wordArt punta a 0x00f0 !!!!!


fix

tavola (che si trova in 0x0ef0) -> 0x00f0
tavola2 -> 0x0ef0
wordArt punta a 0x0ef0 che a sua volta punta a 0x00f0

tavola viene aggiornata e 0x00f0 viene liberato
tavola (che si trova in 0x0ef0) -> 0xf0f0
tavola2 -> 0x0ef0
wordArt punta a 0x0ef0 che a sua volta punta a 0xf0f0


è forse possibile passare la posizione della tavola senza tavola2, non ho provato e non voglio testarlo ora

trueMineCount viene utilizzato per stampare la quantità di bandiere rimanenti, e il motivo perchè uso trueMineCount è perchè se la gameMode non è 0, allora la quantità di bombe effettive sarà diverso da mineCount. trueMineCount contiene la vera quantità di bombe
flagPlaced invece conta la quantità di bandiere piazzate (sempre usato dall'elemento che mostra la quantità di bandiere mancanti)
invece timer è... un timer. è un riferimento a una variabile in main perchè se una nuova partita viene iniziata allora in qualche modo devo resettare sto timer


wordArt tiene una copia delle dimensioni, prende le nuove dimensioni del terminale e controlla se sono uguali o meno rispetto alla copia: se sono diverse allora chiama flushBuffer e aggiorna la copia delle dimensioni con le nuove dimensioni

wordArt ha un sleep di 125ms per evitare di saturare completamente il processore (se non fosse per lo sleep l'animazione non sarebbe più un'animazione). originariamente aveva uno sleep di 1 secondo, ma lo ho ridotto perchè avere un intervallo di tempo di massimo 1 secondo tra quando l'utente ridimensiona il terminale e quando wordArt risponde aggiornando lo schermo era un po' troppo. però, per mantenere la stessa velocità dell'animazione, uso un counter che viene incrementato con ogni singolo ciclo e se supera il numero 8 (125ms * 8 = 1s) allora incrementa il counter "Art" (ovvero il counter che gestisce lo stato dell'animazione)



flushBuffer si occupa di ripulire lo schermo: quando si ridimensiona il terminale, le coordinate della tavola cambiano (per tenerla centrata allo schermo); la tavola che è stata stampata nelle coordinate vecchie persiste, risultando in una tavola "fantasma" dislocata dal centro
flushBuffer rimuove questa tavola fantasma
ha diversi parametri, board, width, height, mineCount, gameMode sono necessari per chiamare printBoard dopo avere ripulito lo schermo, altrimenti la tavola scompare e riappare solo quando l'utente esegue un'azione
mentre win viene utilizzato per capire se l'utente è nelle impostazioni, disabilitando la stampa della tavola se win == 6 (l'utente è nelle impostazioni)
width e height vengono modificati immediatamente al click e le modifiche sono effettive anche se l'utente non ha premuto back per uscire dal menu. il heap non è ancora stato ridimensionato, ma i parametri che ne controllano la dimensione si, risultando in lettura di regioni di memoria invalide e/o SIGSEGV (segmentation fault). non posso garantire la sicurezza della stampa, quindi piuttosto di riscrivere completamente parte della logica, disabilito la stampa

ma perchè flushBuffer deve stampare la tavola? non è che "deve" (infatti in alcune versioni più vecchie non lo faceva), ma avere una funzione che automaticamente esegue un'altra azione piuttosto che avere il chiamante che esegue manualmente l'altra azione è piuttosto comodo.
a parte i motivi di sicurezza di cui ho parlato prima, se flushBuffer viene chiamato allora il chiamante vuole che la tavola venga ristampata



printSettingsMenu:
stampa il menù delle impostazioni (prima stampando il background e poi gli elementi) e ha 5 parametri
update: un counter che indica alla funzione quale opzione l'utente ha selezionato (evidenziando la casella in verde chiaro se la casella non è cliccata, verde scuro se è cliccata)
gli altri 4 parametri (width, height, mineCount e gameMode) servono per stampare all'utente le impostazioni attuali

se però i 4 parametri (width, height, mineCount e gameMode) sono fuori dal range ammesso, printSettingsMenu automaticamente rimette i valori nei range ammessi prima di stampare i numeri

printSettingsMenu ha un id come input e l'id ha un certo significato:
1-9 indica la cella da evidenziare (non cliccato), 1-3 sono le 3 celle in cima (i più), 4-6 solo le 3 celle in mezzo (i numeri), 7-9 sono le 3 celle in fondo (i meno)
11-19 sono la stessa roba però evidenziata
4-6 non vengono mai utilizzati
0 = nessuna evidenziata / cliccata

ho implementato il multi bombe dopo che ho finalizzato il menù delle impostazioni e, piuttosto che rifare gran parte di printSettingsMenu per cambiare gli id, ho creato 4 nuovi id per la selezione delle multi bombe



sigtstp_handler e sigint_handler
come dicono i nomi sono degli handler
sigtstp_handler (^Z) ripulisce il tutto grazie a cleanup e disable_raw_mode e quando il programma ricontinua l'esecuzione reimposta tutte le impostazioni con resume e enable_raw_mode e (si, con una variabile globale di tipo sig_atomic_t per evitare race conditions PERÒ C'È UN BUON MOTIVO: gli handler sono estremamente limitati) stampa la tavola

sigint_handler (^C, anche SIGTERM) invece ripulisce il tutto, disabilita la modalità non canonical grazie a disable_raw_mode ed esce dal programma

questi 2 handler esistono per non lasciare l'utente con un buffer mezzo rotto dove ogni singolo movimento del mouse riesce a ricoprire l'intero schermo con sequenze di escape

ciascuno di essi ha un parametro (il parametro non viene mai usato, potrei condensare i due handler in un singolo handler usando il parametro e una condizione ma onesto sbatti)

