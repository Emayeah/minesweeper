relazione

come si compila: (compiler) ./main.cpp
compiler agnostic, non è necessario includere librerie oltre a quelle standard, main.cpp automaticamente include i header locali (rawmode.h e prototype.h)
le due costanti (devBit e showInfoBit) scopo debugging

decisioni prese e perchè
ho usato un'array monodimensionale e non bidimensionale perchè non volevo usare dei vettori per fare la tavola e mi serviva un modo per ridimensionare la tavola, cosa che non si può fare con le array bidimensionali (il compiler deve sapere al compile time la dimensione)
ho scelto di implemtare i controlli keyboard driven e mouse driven perchè sono molto più intuitivi rispetto a manualmente scegliere coordinate, però rendendo il programma esclusivo linux / posix compliant (o wsl), le sequenze ANSI sono uste molto spesso

ho usato delle emoji per stampare la tavola perchè rende il gioco più giocabile, va bene il non compatibile ma se il tuo terminal emulator non è compatibile allora è il momento di cambiare terminal emulator. è possibile renderlo compatibile con emulatori che non hanno il supporto per unicode / rendering di emoji.

perchè stampo i colori dei numeri? per differenziare più facilmente i numeri tra di loro, quelli che giocano a minesweeper 24/7 usano i colori per identificare più velocemente il numero. non sono li a caso, sono gli stessi colori trovati nell'implementazione originale di campo minato di microsoft.

letteralmente tutti i terminal emulator supportano i colori, pure fbcon. questo programma è stato sviluppato con linux in mente, sono piuttosto sicuro che wsl ha il supporto per ansi. dopotutto tutto questo è puramente grafico e cambiare l'output è questione di modificare condizioni e il contenuto nel blocco di codice contenuto nella funzione printBoard

ho deciso di rendere il programma agnostico alla quantità di bombe e dimensione, che brutto fare il hard code. ho testato il programma con diverse configurazioni di dimensioni. ho pure aggiunto un menù per cambiare la quantità di bombe e la dimensione della tavola


ho aggiunto delle modalità extra, ovvero la "multibomba"
normalmente ogni singola cella può contenere o 0 bombe o 1 bomba, ma ho implementato un'opzione per fare in modo tale che ogni singola cella può avere 0, 1 o 2 bombe (fino a 5, è possibile scegliere livelli)
questa modalità forza l'utente a pensare di più, perchè il significato dei numeri diventa ambiguo. normalmente, se un "3" affianca 3 celle, ogni singola cella ha una bomba; se invece si attiva la modalità "3 bombe", non è più garantito che ci sia una bomba in 3 celle diverse, potrebbe essere che ci siano 3 bombe in una singola cella o 2 bombe in una e 3 in un altra


la titlebar in cima è pure animata, e se la si clicca allora viene iniziata una nuova partita, accanto ci sono il timer e la quantità di bandiere rimanenti, opzioni stilistiche per renderlo simile all'implementazione originale

la tavola sta nel heap (con new, non malloc) così posso ridimensionare la tavola. potrei usare malloc ma...	troppo difficile
ho usato dei short ovunque per l'utilizzo della memoria dimezzata (il numero più grande che mi serve è tipo 300, byte non è abbastanza ma int è overkill)


i codici (ovvero quale numero equivale a quale casella)
0 scoperto
10 coperto
20 evidenziato giallo
30 evidenziato nero (evidenziato una casella scoperta)
40 evidenziato arancione (cliccato)

51 (o 42 o quello che è)
1o numero = quantità di bombe + 4
51 = ha (5 - 4 = 1) bombe
71 = ha (7 - 4 = 3) bombe
2o numero = quantità di bandiere + 1
42 = ha (4 - 4 = 0) bombe e (2 - 1 = 1) bandiere
63 = ha (6 - 4 = 2) bombe e (3 - 1 = 2) bandiere

x = bandiera evidenziata, x = quantità di bandiere + 1

>100 e <=200 numeri
>200 numeri evidenziati


perchè sti codici altamente stupidi? i codici li ho fatti *dopo* che ho finito il programma (ovvero avevo già finito il menù delle impostazioni)
avevo rifatto dei codici e modificato il programma con questi nuovi codici, però dopo avere finito mi sono reso conto che i codici non solo erano stupidissimi, non andavano bene affatto e avevano problemi seri (per esempio: il programma non aveva modo per sapere se la cella aveva 2 bandiere e 2 bombe, poteva solo sapere se una cella aveva o una certa quantità di bandiere o una certa quantità di bombe. piazzando una bandiera sovrascriveva la quantità di bombe e... eh)
quindi ho dovuto rifare i codici per le bombe da 0, piuttosto che rifare TUTTI i codici da 0 per renderli puliti ho rifatto i codici per le bombe cercando di mantenere retrocompatibilità (tenendo il 10 per coperto, 0 per scoperto, 20 per evidenziato giallo)

i codici sono piuttosto stupidi e si potrebbero migliorare, per esempio trasformare l'evidenziato giallo con id 80 (0 bandiere) e fare in modo tale che i numeri dei codici delle bombeequivalgono alla quantità effettiva di bombe e bandiere senza strani offset (ovvero 21 = 1 bomba 1 bandiera, 0 riservato per la cella scoperta, è meglio che un offset di 1 per la bomba rimanga)
(in poche parole non avevo tantissimo tempo)


non ho usato un'array associata per le bombe, usarne una PUÒ rendere il compito più semplice se si parla di 100 righe ma sto programma ha superato la soglia dei 1100.
le array associate in generale sono stupidi, o c'è un vero motivo per usarne una (quando NON avere un array associata è la decision più stupida, tipo come ho fatto con i colori) o non la si usa.



cosa fa main
main non fa un cavolo in realtà, lo scope di int main si è gradualmente ridotto ed è tipo la quartultima funzione in termini di lunghezza
oltre a non fare un cavolo, stampa la quantità delle bandiere rimanenti. perchè lo stampo qui anche se viene stampata in wordArt? visto che wordArt va in pausa per 125ms, si può sentire un piccolo delay tra quando si piazza una bandiera e quando il numero viene aggiornato. mettendolo subito dopo la chiamata a userInput (userInput ritorna il controllo a main se succede un evento tipo mettere una bandiera o cliccare una cella), posso garantire che (si, eccetto un piccolo delay per il mutex e per lo scope piuttosto alto tra quando il click viene eseguito e quando userInput ritorna) la quantità viene aggiornata entro 30ms

perchè main fa così poco? c'è stato un po' di scope creep e feature creep (la cella evidenziata in giallo, supporto per la tastiera e il mouse...) e molta logica che controlla il flow è stata collocata in userInput (perchè mi pareva il modo più semplice. era la decisione migliore? probabilmente no, ma funziona assai bene)



initBoard:
serve un modo per creare la tavola e piazzare le bombe
ha come parametro trueMineCount: anche se mineCount == 30, se gameMode != 0 allora non è garantito che la tavola abbia 30 bombe, trueMineCount contiene la quantità reale di bombe

trueMineCount serve a wordArt per stampare la quantità di bandiere rimanenti
se io voglio stampare la quantità di bandiere rimanenti da posizionare, devo in qualche modo trovare il vero numero delle bombe, initBoard automaticamente aggiorna trueMineCount durante l'inizializzazione della tavola



printBoard:
se lose == 1 allora le bombe (anche coperte) vengono stampate in ross e stampa le bandiere posizionate in posti errati in colori diversi, indicando l'utente che ha appena perso cosa ha sbagliato

visto che la maggior parte di terminal emulator hanno il supporto per unicode ed emoji, ho optato per i caratteri unicode per rendere il gioco più giocabile e più bello. si, non sarà 100% compatibile ma preferisco avere un gioco giocabile

un emoji gialla viene usata per indicare la casella selezionata, e le bombe vengono visualizzate se si vince (o perde) con emoji rosse. la bandiera rossa indica una bandiera, una bandiera rossa con lo sfondo bianco indica una bandiera posizionata in un posto scorretto (mostrato quando si perde), mentre una bandiera rossa con lo sfondo rosso indica una bandiera posizionata correttamente (anche essa mostrata quando si perde. se si piazza una bandiera su un posto contenenti 3 bombe, il gioco lo considera sbagliato, inserendo uno sfondo bianco)
un emoji arancione viene usata per indicare che l'utente ha il tasto cliccato, ho aggiunto l'emoji arancione per dare un feedback visivo all'utente segnalando che il programma ha ricevuto il click

quando gameMode è diverso da 0, certi elementi come la quantità di bandiere e altro vengono stampati in modi diversi, per esempio al posto di stampare bandiere, numeri vengono stampati (perchè non esistono emoji contenenti 3 o più bandiere)

ho usato una array associata che contiene gli id dei colori per stampare i colori dei numeri, originariamente avevo una catena di switch case lunga quasi 120 righe ma mi son reso conto che forse avere un'array associata e usando il valore del numero è l'idea migliore, rendendo il codice più pulito e facendo meno controlli di eguaglianza

usando le dimensioni del terminale la tavola viene posta al centro (non ho voluto fare il hard-code, questo permette il gioco di rispondere correttamente casomai ci siano eventuali ridimensionamenti del terminale)

printBoard stampa il perimetro della tavola con delle emoji verdi, mente stavo facendo il playtest della tavola centrata ho immediatamente scoperto che era difficile capire quale era il perimetro quando gran parte della tavola era scoperta, avendo un perimetro verde fa in modo tale che questo non succede mai


cosa fa userInput (il vero main)
userInput gestisce l'input dell'utente, facendo il parsing delle sequenza di escape ANSI per l'input mouse E tastiera
ho impostato il any event tracking e il SGR (esc[?1003 e esc[?1006) a high, il primo per ricevere in input lo stato del mouse (click e non click) e altri eventi, il secondo per impostare le sequenze con un formato diverso (usando numeri leggibili tipo 12, 35 piuttosto che caratteri ASCII con il valore corrispondente che si fermano a 255).

openSettings serve per modificare il flow del programma in base a se il menù delle impostazioni è aperto o meno e flagPlaced viene passato perchè ci sono altre funzioni chiamate da userInput che effettivamente modificano flagPlaced (perchè per riferimento? la funzione asincrona wordArt è il motivo perchè flagPlaced esiste, non ha senso passarlo per valore)

tastiera: se l'input è uguale a freccia giù (esc[B) allora incrementa y e così via
ho aggiunto il supporto per i tasti fine, inizio, pgsu e pggiù per rendere più veloce navigare la tavola, li ho aggiunti prima che abbia implementato il supporto per il mouse ma ho deciso di tenere il supporto per la tastiera
non tuttissimi i terminali supportano l'input (kmscon però supporta l'input con il mouse) e non è tanto bello eliminare del lavoro che non interferisce con altri pezzi

visto che la tavola è sempre centrata, il mouse, (sparo) per puntare alla prima cella in cima a sinistra, deve puntare a (sparo) 30x e 20y. devo però rimuovere dalle coordinate del mouse gli stessi offset che ho aggiunto alla stampa per centrare la tavola, per fare in modo tale che 30x e 20y equivalgano a 0x e 0y
però devo dividere le y (le orizzontali) per 2 perchè un'emoji occupa 2 spazi (ogni singolo carattere è tipo 8x16 pixel di default? 2 caratteri fanno un quadrato)


originariamente per "liberare" una cella era possibile premere qualsiasi tasto, al posto di fare qualsiasi tasto lo ho cambiato a "d" (delete, accanto a flag in una tastiera qwerty)
però, ci sono alcune modalità del mouse che non ho implementato (tipo il middle click e altri) risultando in click possibilmente involontari.

il valore della cella viene salvata in valBak e il valore della cella selezionata viene sovrascritto con un id che corrisponde a quella tipologia della casella però selezionata appena prima di chiamare printBoard
esempio: se la cella è un numero allora += 100; altrimenti se la cella è coperta (bianca) allora 20 (giallo), se invece la cella è scoperta (nera) allora 30 (nero però emoji)
lo ho implementato in questo modo per evitare casini e per prevenire che, per colpa di qualche errore da parte mia, il valore della cella venga permanente sovrascritto

è la funzione più "complessa" e la più difficile da navigare (ha molte condizioni), tutte le condizioni servono per vedere quale azione l'utente vuole eseguire

userInput esegue le azioni (tipo mettere una bandiera, cliccare...) quando l'utente lascia andare il tasto, non quando lo preme, non riesco a sopportare tasti o eventi che si attivano quando si preme il tasto e non quando lo si lascia andare

la logica per il menù delle impostazioni aveva tantissime condizioni, le ho condensate in una sola. ho aggiunto il plusOrMinus per indicare se bisogna aggiungere o togliere 1
era molto molto non ottimizzato, c'era una condizione per ogni singola cosa, molte molte condizioni ridondanti


calcAdjacent:
se l'utente clicca su una cella, bisogna in qualche modo capire quante bombe sono vicine a questa cella per poi piazzare un numero (non calcola solo bombe)

calcola la quantità di un determinato tipo di casella attorno ad una casella

calcAdjacent ha pure un selettore modalità, 0 calcola le bombe (coperte con o senza flag), utilizzato per calcolare il numero che deve essere posizionato
ho voluto usare un selettore della modalità piuttosto che separare la funzione in diverse funzioni perchè i due cicli sono gli stessi, l'unica cosa che cambia è il cosa viene contato

ritorna la quantità di una determinata casella vicino al posto al chiamante



expandBoard
se l'utente clicca su una casella con valore 0 allora bisogna in qualche modo fare questa reazione a catena di zeri
(ho deciso di deprecare il debugBit perchè mi sembra piuttosto inutile ormai)
anche flagPlaced viene passato, se l'utente piazza una bandiera su un posto che non contiene una bomba e expandBoard elimina la bandiera seguendo una reazione a catena, expandBoard modifica flagPlaced perchè una bandiera è stata rimossa

il metodo in cui il programma fa la reazione a catena nel caso in cui una casella contenente uno 0 viene scoperta (quando tutte le caselle adiacenti alla casella cliccata non contengono bombe):

abbiamo un'area 3x3 (il centro è la casella cliccata)
tutte le caselle (non solo il preimetro) vengono controllate per vedere se accanto ad essa c'è una casella scoperta (con uno zero), se si allora la quantità di bombe adiacenti alla casella viene calcolata, e il numero viene posizionato sovrascrivendo il valore della casella che viene controllata
(se la casella che viene controllata è una bomba allora è impossibile che accanto ci sia un numero con valore zero, se questo non è il caso allora il programma contiene un bug)

poi, con un counter che incrementa la dimensione dell'area che deve essere controllata, l'area che deve essere controllata diventa 5x5
tutte le caselle in quel 5x5 (non solo il perimetro, questo metodo NON funzionerebbe se solo il perimetro viene controllato) vengono controllate per vedere se accanto c'è una casella scoperta con valore di 0...
tutto questo viene ripetuto fin quando un flag (che controlla se il valore di una casella è stato cambiato) rimane di valore 0 (ovvero nessuna casella è stata "scoperta")

ho implementato questo modo perchè mi sembrava molto semplice, effettivo e non stupido da un punto di vista di risorse utilizzate. è (più o meno) un algoritmo O(2n^2) si, ma l'utente non giocherà mai con una tavola più grande di 150x100, non perchè non è pazzo ma perchè la dimensione del terminale diventa una limitazione. poi, preferisco avere un algoritmo semplice ma non il migliore piuttosto che una soluzione complessissima che magari in certi casi strani non funziona
stavo pensando di fare le recursion all'inizio ma non avendole mai fatte non volevo complicarmi la vita così tanto, ho letteralmente preso un foglio excel (libreoffice), ho ridimensionato le celle rendendole quadrate e ho iniziato a pensare come avrei potuto calcolare tutto questo. 



cleanup si occupa di disabilitare:
il buffer alternativo
l'input mouse
la modalità non canonical
e si occupa di riabilitare il cursore
praticamente serve per ripulire le impostazioni impostate dal programma, se il programma per qualsiasi motivo uscisse senza disabilitare queste impostazioni l'utente rimarrebbe in un buffer alternativo con un mouse in grado di inondare lo schermo con caratteri

resume si occupa di abilitare:
il buffer alternativo
l'input mouse
la modalità non canonical
e si occupa di disabilitare il cursore
questa invece serve per riabilitare le impostazioni, se per qualche motivo le impostazioni non fossero caricate l'input (sia con il mouse sia con la tastiera) non funzionerebbe

le 2 funzioni sono usati dai 2 handler e da main, ho spostato i due in funzioni separate perchè capire il funzionamento è molto più immediato grazie al nome della funzione



getMouseVal invece è la funzione che si occupa del parsing dell'input del mouse
ritorna un numero e serve per recuperare le coordinate del mouse, la modalità e l'evento del click
ha una variabile passata per riferimento, serve come un secondo return (per ritornare al chiamante un altro valore)

piuttosto che avere userInput che fa il parsing (creando casini e rendendo il codice difficile da leggere), ho spostato il tutto in una funzione, rendendo il codice più snello e semplice da leggere

visto che l'input ha più di un carattere, quello che faccio è leggere il primo numero e metterlo nella somma, se c'è un altro numero dopo il primo numero allora la somma è moltiplicata per 10 e il nuovo munero è aggiunto, se c'è un terzo numero allora la somma viene moltiplicata per 10 e il risultato aggiunto alla somma...

getMouseVal non si deve preoccupare dei primi 3 caratteri (esc[<) perchè il chiamante (userInput) chiama getMouseVal solo se ha stabilito che la sequenza di escape si tratta di una sequenza del mouse (esc[< non sono più nel buffer)



clickLogic viene chiamato per controllare la validità di certe azioni e ha diversi parametri
anche questo ha più modalità, non c'è proprio un motivo proprio valido per avere un selettore modalità, la funzione potrebbe tranquillamente essere spezzata 

se clickLogic rileva che l'utente ha cliccato una bomba o ha tentato di fare il chording accanto ad una bomba non flaggata allora ritorna automaticamente 1, segnalando una sconfitta. non ha senso procedere a fare altri controlli, perchè l'utente ha perso

calcola anche se l'azione è su una cella valida, ovvero non puoi bandierare una cella vuota con valore 0



wordArt: è una funzione asincrona
originariamente wordArt animava solo la titlebar ed esisteva puramente per motivi stilistici ma, essendo un while true asincrono, ho iniziato ad usarlo per altre robe (ovvero ripulire lo schermo, il timer e le bandiere rimanenti) perchè era molto comodo. userInput in realtà passa mooolto tempo aspettando l'input dell'utente; incaricare userInput (o altre funzioni nel 1o thread) non funzionerebbe perchè questi aggiornamenti vengono effettuati solo quando l'utente esegue qualche azione

si occupa di 3 robe
1. di animare la titlebar (motivi puramente estetici)
2. di pulire lo schermo se lo schermo è stato ridimensionato tramite flushBuffer
3. di mostrare la quantità di bandiere rimanenti e quanti secondi sono passati
ha 9 parametri, 5 di essi (board, width, height, mineCount e gameMode) utilizzati da flushBuffer quando deve stampare la tavola
board non è un riferimento alla tavola, ma è un riferimento ad un riferimento alla tavola. perchè?

quando il heap viene ripulito e una nuova regione del heap viene allocata, insieme ad esso ci sta anche un nuovo pointer. anche se il pointer della tavola viene cambiato, wordArt ha ancora il pointer della regione della memoria dove ci stAVA la tavola, risultando in un UAF.
invece, se passo un riferimento (che è garantito di stare nella stessa parte della memoria) che punta all'indirizzo di memoria di board, è possibile recuperare l'indirizzo aggiornato della tavola tramite il riferimento

board (0x0ff0) -> tavola (0x00f0)
wordArt -> tavola (0x00f0)

tavola viene liberata e una nuova allocata in 0xe0f0
board(0x0ff0) -> tavola (0xe0f0)
wordArt -> tavola (0x00f0) !!!!!

fix

board(0x0ff0) -> tavola (0x00f0)
wordArt -> board (0x0ff0) -> tavola (0x00f0)

tavola viene liberata e una nuova allocata in 0xe0f0
board(0x0ff0) -> tavola (0xe0f0)
wordArt -> board (0x0ff0) -> tavola (0xe0f0)

trueMineCount viene utilizzato per stampare la quantità di bandiere rimanenti, motivi puramente estetici
flagPlaced invece conta la quantità di bandiere piazzate (sempre usato dall'elemento che mostra la quantità di bandiere mancanti)
invece timer è... un timer. è un riferimento a una variabile in main perchè se una nuova partita viene iniziata allora in qualche modo devo resettare sto timer. anche questo esiste per scopi estetici


wordArt tiene una copia delle dimensioni, prende le nuove dimensioni del terminale e controlla se sono uguali o meno rispetto alla copia: se sono diverse allora chiama flushBuffer e aggiorna la copia delle dimensioni con le nuove dimensioni

wordArt ha un sleep di 125ms per evitare di saturare completamente il processore (se non fosse per lo sleep l'animazione non sarebbe più un'animazione). originariamente aveva uno sleep di 1 secondo, ma lo ho ridotto perchè lo scope di wordArt si è ingrandito e avere un intervallo di tempo di massimo 1 secondo tra quando l'utente ridimensiona il terminale e quando wordArt risponde aggiornando lo schermo era un po' troppo. però, per mantenere la stessa velocità dell'animazione, uso un counter che viene incrementato con ogni singolo ciclo e se supera il numero 8 (125ms * 8 = 1s) allora incrementa il counter "Art" (ovvero il counter che gestisce lo stato dell'animazione)



flushBuffer si occupa di ripulire lo schermo:
quando si ridimensiona il terminale, le coordinate della tavola cambiano (per tenerla centrata allo schermo); la tavola che è stata stampata nelle coordinate vecchie persiste, risultando in una tavola "fantasma" dislocata dal centro
flushBuffer rimuove questa tavola fantasma
win viene utilizzato per capire se l'utente è nelle impostazioni, disabilitando la stampa della tavola se win == 6 (l'utente è nelle impostazioni)
width e height vengono modificati immediatamente al click e le modifiche sono effettive anche se l'utente non ha premuto back per uscire dal menu. il heap non è ancora stato ridimensionato, ma i parametri che ne controllano la dimensione si, risultando in lettura di regioni di memoria invalide e/o SIGSEGV (segmentation fault). non posso garantire la sicurezza della stampa, quindi piuttosto di riscrivere completamente parte della logica, disabilito la stampa

ma perchè flushBuffer deve stampare la tavola? non è che "deve" (infatti in alcune versioni più vecchie non lo faceva), ma avere una funzione che automaticamente esegue un'altra azione piuttosto che avere il chiamante che esegue manualmente l'altra azione è piuttosto comodo.
a parte i motivi di sicurezza di cui ho parlato prima, se flushBuffer viene chiamato allora il chiamante vuole che la tavola venga ristampata



printSettingsMenu:
stampa il menù delle impostazioni (prima stampando il background e poi gli elementi) e ha 5 parametri
update: un counter che indica alla funzione quale opzione l'utente ha selezionato (evidenziando la casella in verde chiaro se la casella non è cliccata, verde scuro se è cliccata)
gli altri 4 parametri (width, height, mineCount e gameMode) servono per stampare all'utente le impostazioni attuali

se però i 4 parametri (width, height, mineCount e gameMode) sono fuori dal range ammesso, printSettingsMenu automaticamente rimette i valori nei range ammessi prima di stampare i numeri

printSettingsMenu ha un id come input e l'id ha un certo significato:
1-20 indica la cella da evidenziare (non cliccato), 1-3 sono le 3 celle in cima (i più), 4-6 solo le 3 celle in mezzo (i numeri), 7-9 sono le 3 penultime celle in fondo (i meno), 10 e 12 sono le ultime (selettore modalità)
21-40 sono la stessa roba però evidenziata
4-6 in realtà non vengono mai utilizzati
0 = nessuna evidenziata / cliccata



sigtstp_handler e sigint_handler
come dicono i nomi sono degli handler
sigtstp_handler (^Z) ripulisce il tutto grazie a cleanup e disable_raw_mode e quando il programma ricontinua l'esecuzione reimposta tutte le impostazioni con resume e enable_raw_mode e (si, con una variabile globale di tipo sig_atomic_t per evitare race conditions PERÒ C'È UN BUON MOTIVO: gli handler sono estremamente limitati) stampa la tavola

sigint_handler (^C, anche SIGTERM) invece ripulisce il tutto, disabilita la modalità non canonical grazie a disable_raw_mode ed esce dal programma

questi 2 handler esistono per non lasciare l'utente con un buffer mezzo rotto dove ogni singolo movimento del mouse riesce a ricoprire l'intero schermo con sequenze di escape

ciascuno di essi ha un parametro (il parametro non viene mai usato, potrei condensare i due handler in un singolo handler usando il parametro e una condizione ma onesto sbatti)

